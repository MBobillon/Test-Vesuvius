#include <liblas/liblas.hpp>
#include <fstream>
#include <iostream> // std::cout
#include <vector>
#include <array>

// Point Class with some mathematical functions
class Point
{
   public:
   Point(double x = 0., double y = 0., double z = 0.){
       m_coord[0] = x;
       m_coord[1] = y;
       m_coord[2] = z;
   }    

   double* data() { return m_coord.data(); }

    double x() const {return m_coord[0];}
    double y() const {return m_coord[1];}
    double z() const {return m_coord[2];}

    double operator[]( size_t i) const { return m_coord[i];}
    double& operator[]( size_t i){ return m_coord[i];}

    Point operator-(const Point& v) const {
        return {x() - v.x(), y() - v.y(), z() - v.z()};
    }

    Point cross(const Point& v) const {
        return {
            y() * v.z() - z() * v.y(),
            z() * v.x() - x() * v.z(),
            x() * v.y() - y() * v.x()
        };
    }

    double dot(const Point& v) const {
        return x() * v.x() + y() * v.y() + z() * v.z();
    }
    private:
    std::array<double,3> m_coord;
};
using Vector = Point;

// static function which load a .LAS file and return the points whose intensity is at 100%
static 
std::vector<Point> st_pointsOnReflectorBand(const std::string& lasFilePath) 
{
    std::vector<Point> points;

    std::ifstream ifs(lasFilePath, std::ios::in | std::ios::binary);
    if (!ifs) {
        std::cerr << "Erreur d'ouverture du fichier LAS : " << lasFilePath << std::endl;
        return points;
    }

    liblas::ReaderFactory readerFactory;
    liblas::Reader reader = readerFactory.CreateWithStream(ifs);

    double max_intensity = 0.;
    while (reader.ReadNextPoint()) 
    {
        const liblas::Point& point = reader.GetPoint();
        double intensity = static_cast<double>(point.GetIntensity());
        if(intensity >= 200 /*255*/ /*65535*/) // maximal inensity => the point is on the reflector strip band
        {           
            double x = point.GetX();
            double y = point.GetY();
            double z = point.GetZ();
            points.push_back({x, y, z});
        }
        if (max_intensity < intensity)
            max_intensity = intensity;
    }

    return points;
}

class Triangle {
public:
    Triangle() { ; }
    
    Point& p0() { return m_p0; }
    Point& p1() { return m_p1; }
    Point& p2() { return m_p2; }
    Point& normal() { return m_normal; }

    const Point& p0() const { return m_p0; }
    const Point& p1() const { return m_p1; }
    const Point& p2() const { return m_p2; }
    const Point& normal() const { return m_normal; }

private:
    Point m_p0, m_p1, m_p2;
    Vector m_normal;
};

std::vector<Triangle> readBinarySTL(const std::string& filename) {
    std::vector<Triangle> triangles;

    std::ifstream file(filename, std::ios::binary);
    if (!file) {
        std::cerr << "Erreur : impossible d'ouvrir le fichier " << filename << std::endl;
        return triangles;
    }

    // Ignorer l'en-tÃªte de 80 octets
    file.ignore(80);

    // Lire le nombre de triangles
    uint32_t numTriangles = 0;
    file.read(reinterpret_cast<char*>(&numTriangles), sizeof(uint32_t));

    for (uint32_t i = 0; i < numTriangles; ++i) {
        float normal[3];
        float v0[3], v1[3], v2[3];

        file.read(reinterpret_cast<char*>(normal), sizeof(normal));
        file.read(reinterpret_cast<char*>(v0), sizeof(v0));
        file.read(reinterpret_cast<char*>(v1), sizeof(v1));
        file.read(reinterpret_cast<char*>(v2), sizeof(v2));

        // Ignore attribute byte count (2 bytes)
        file.ignore(2);

        Triangle tri;
        tri.p0() = Point(v0[0], v0[1], v0[2]);
        tri.p1() = Point(v1[0], v1[1], v1[2]);
        tri.p2() = Point(v2[0], v2[1], v2[2]);
        tri.normal() = Point(normal[0], normal[1], normal[2]);

        triangles.push_back(tri);
    }

    return triangles;
}

// function to compute the volume of a tetrahedron generated by a triangle to which we add origin point (0.,0.,0.)
static
double st_signedVolumeTetrahedon(  const Triangle& tri)
{
   return (tri.p0().cross(tri.p1())).dot(tri.p2());
}

double st_computeVolumeMesh(const std::vector<Triangle>& triangles)
{
    double volume = 0.0;
    for (const Triangle& tri : triangles)
       volume += st_signedVolumeTetrahedon (tri);  
    return std::abs(volume) / 6.0;
}

int main()
{
    // Challenge 1 :
    Point centroid; // by default = {0., 0.,0.};
    std::vector<Point> pointsReflector = st_pointsOnReflectorBand("reflector.las");
    size_t nP = pointsReflector.size();

    if(nP > 0)  
    {
       // In this case, we make the approximation that centroid of the reflector band is close to the barycentre of points.
       // Because we suppose that thes points of cloud have a good repartition on this band ("they "was pointing at a reflector strip band.")
        for (const Point& P : pointsReflector) 
            for (size_t i  =0 ; i <= 2 ;++i)
                centroid[i] += P[i];

         std::cout << "Centroid: (" << centroid[0] << ", " << centroid[1] << ", " << centroid[2] << ")\n";
    }
    else std::cout << "No detected points on reflector strip band.\n";
       

    std::vector<Triangle> triangles = readBinarySTL("mesh.stl");

    double volume = st_computeVolumeMesh(triangles);
    double volumeLiter = volume / 1000000;
    double volumeCubicMeter = volumeLiter / 1000;
    std::cout << " Volume of our mesh is : " << volume << " cubic mm\n";
    std::cout << " Volume of our mesh is : " << volumeLiter << " liters \n";
    std::cout << " Volume of our mesh is : " << volumeCubicMeter << " cubic meters \n";
    
    return 0;
}
